1. 암호화(원래대로 돌릴 수 없음)(인크립션) <-> 복호화 (암호화의 반대)(디크립션) ==> 서명(시그니처)
2. 인코딩(정해진 규격에 맞추어 암호화를 함) -> 원래대로 돌릴 수 있음 <-> 디코딩(인코딩의 반대)

암호화 <(양방향)> 복호화
암호화 -(단방향)> 복호화

같은 키로 암호화 하면 같은 값이기 때문에 DB에서 들어온 pw를 암호화 해서 기존에 있던 키와 비교한다.

Session ID의 단점
- 표(누구의 것인지 확인할 수 있음)를 관리해야 된다( 메모리를 사용함 )(서버의 리소스를 많이 쓴다.)=> 서버측에 부담

토큰 => 관리하지 않아도 됨.

Token (사용시간(라이프타임)이 담겨있음)

토큰은 웹서버(스프링의 경우 시큐리티)에서 확인함 
-  토큰의 무결성 확인 (암호화 프로그램을 넣어놓음, 자기가 만든건지 아닌지 알 수 있음)=> 변질여부, 라이프타임이 남아 있는지를 알 수 있음

세션은 인가라는 것을 특별히 따질 필요가 없음

인증 :사용자의 신원을 검증하는 프로세스 (ex) 로그인
인가 : 인증 이후의 프로세스, 인증된 사용자가 어떠한 자원에 접근할 수 있는지를 확인하는 절차( 권한 확인 )

Maven Reposiotory -> Spring Boot Starter Security -> 3.1.5

Client -(HTTPS)(암호화 된 패킷을 주고 받을 때 사용)> Server(SSL: 암호화 인증키)