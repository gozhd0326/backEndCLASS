* @RequestBody 와 @Valid *

1. @RequestBody 어노테이션 :
   - 클라이언트가 보낸 JSON 형식의 HTTP 요청 본문을 자바 객체로 변환해주는 역할을 함.
     (클라이언트가 전송한 JSON 형태의 HTTP Body 내용을 Java Object로 변환시켜주는 역할) 
     => 이 변환 과정을 직렬화(Serializiton)이라고 함.

   - @RequestBody를 사용하지 않으면, HTTP 요청의 본문은 자동으로 Java 객체로 변환되지 않음.

   - 클라이언트로부터 전달받은 데이터가 HTTP 요청의 본문에 포함되어 있고,
     이를 Java 객체로 변환하여 처리해야 하는 경우에는 @RequestBody를 사용해야 함.

   => 따라서 클라이언트가 보낸 데이터를 자바 객체로 받아서 사용하려면 이 어노테이션을 사용해야 함.

2. @Valid 어노테이션은 :
   - 검증(Validation)을 수행하라는 의미임. 이 어노테이션이 붙어 있는 객체가 검증을 받아야 하는 객체임을 나타냄.
      ( @RequestBody로 변환된 Java Object의 유효성 검사를 수행하는 역할 )
   
   - @Valid를 사용하면, Spring MVC는 해당 객체의 유효성 검사를 수행하고,
   
   - 유효성 검사에 실패한 경우에는 MethodArgumentNotValidException이 발생함.
   
   - @Valid 어노테이션을 사용하려면 해당 객체의 클래스에 유효성 검사를 위한 어노테이션들이 적용되어 있어야 함.
   - ex ) @NotNull, @Size, @Email 등의 어노테이션을 사용하여 필드에 제약조건을 둘 수 있음.

   => 따라서, 객체의 유효성 검사를 수행하려면 @Valid를 사용해야 함.


=> @RequestBody는 클라이언트로부터 받은 JSON 데이터를 Java Object로 변환하는 것이고,
 @Valid는 이 변환된 Object의 유효성을 검사하는 것임.
 이 두 어노테이션은 함께 사용되어야 하므로, @Valid를 사용하려면 @RequestBody를 반드시 사용해야 함.


- @RequestBody와 @Valid를 사용하지 않아도, 개발자가 직접 데이터 변환과 유효성 검사 로직을 구현할 수 있음.
- ex )
       -  JSON 문자열을 직접 파싱하여 Java 객체를 생성
       - 유효성 검사를 위한 메서드를 직접 호출하는 방법



- ex )
@PutMapping("api/classRoom/update/{classRoomId}")
@PreAuthorize("hasAnyRole('ADMIN','PROFESSOR','USER')")
ResponseEntity<ResponseDto<ClassRoom>> updateClassRoom(@PathVariable Long classRoomId, @RequestBody @Valid ClassRoomUpdateDto classRoomDto){
	return new ResponseEntity<>(classRoomServiceImpl.updateClassRoom(classRoomId, classRoomDto), HttpStatus.OK);
}

=> 클라이언트가 보낸 데이터를 검증하고, 검증된 데이터로 ClassRoom의 상태를 업데이트하려면 @RequestBody와 @Valid 어노테이션을 사용해야 함.

=> 클라이언트가 보낸 데이터를 ClassRoomUpdateDto 객체로 변환하고, 이 객체의 검증을 수행한 후,
  검증된 데이터로 ClassRoom의 상태를 업데이트하게 됨. 이는 코드의 안정성을 높이는 데 도움이 됨.

=> 다만, 모든 POST나 PUT 메소드에서 @RequestBody를 사용해야 하는 것은 아님.
 만약 클라이언트로부터 받은 데이터가 단순히 문자열이나 숫자 등의 기본 타입이라면 @RequestBody 없이도 처리할 수 있음.
 @RequestBody는 클라이언트로부터 받은 데이터를 복합 객체로 변환할 때 사용함.



** @RequestBody를 사용하여 클라이언트로부터 전달받은 JSON 데이터를 바로 도메인 모델 클래스(예: User, Order 등)로 변환하면 생기는 문제점 **
 
1. 도메인 모델 클래스가 노출됨.
  
   - 클라이언트는 도메인 모델 클래스의 구조를 알 수 있게 되므로, 애플리케이션의 내부 구조가 외부로 노출됨.
  
   - 이는 보안상 좋지 않음.


2. 데이터 유효성 검사가 어려움.
   
   - @RequestBody로 도메인 모델 클래스를 바로 사용하면, 클라이언트로부터 전달받은 데이터가 올바른지 검사하기 어려움.
   
   - ex )
	 클라이언트가 User 객체를 생성하려고 할 때,
	 필요한 필드가 모두 존재하는지, 각 필드의 값이 올바른 범위 안에 있는지 등을 검사해야 하는데,
	 이런 검사를 DTO 없이 하려면 매우 복잡해짐.

3. 도메인 모델 클래스의 변경이 어려움.
   - 만약 도메인 모델 클래스가 변경되면, 이에 따라 클라이언트와 서버 간의 통신 방식도 변경되어야 함.
   - 이는 유지보수를 어렵게 만듭니다. 반면에 DTO를 사용하면, 도메인 모델 클래스와 클라이언트 간의 데이터 전달 형식을 분리할 수 있음.
   -  따라서 도메인 모델 클래스가 변경되더라도 DTO를 통해 이를 클라이언트에게 숨길 수 있음.

=> 따라서 위와 같은 이유로, 실제 애플리케이션에서는 @RequestBody를 사용할 때 DTO를 함께 사용하는 것이 좋음.